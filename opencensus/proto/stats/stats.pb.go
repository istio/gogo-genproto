// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: opencensus/proto/stats/stats.proto

/*
	Package opencensus_proto_stats is a generated protocol buffer package.

	It is generated from these files:
		opencensus/proto/stats/stats.proto

	It has these top-level messages:
		MeasurementDescriptor
		DistributionAggregation
		DistributionAggregationDescriptor
		IntervalAggregation
		IntervalAggregationDescriptor
		Tag
		ViewDescriptor
		DistributionView
		IntervalView
		View
*/
package opencensus_proto_stats

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Fundamental units of measurement supported by Census
// TODO(aveitch): expand this to include other S.I. units?
type MeasurementDescriptor_BasicUnit int32

const (
	MeasurementDescriptor_UNKNOWN   MeasurementDescriptor_BasicUnit = 0
	MeasurementDescriptor_SCALAR    MeasurementDescriptor_BasicUnit = 1
	MeasurementDescriptor_BITS      MeasurementDescriptor_BasicUnit = 2
	MeasurementDescriptor_BYTES     MeasurementDescriptor_BasicUnit = 3
	MeasurementDescriptor_SECONDS   MeasurementDescriptor_BasicUnit = 4
	MeasurementDescriptor_CORES     MeasurementDescriptor_BasicUnit = 5
	MeasurementDescriptor_MAX_UNITS MeasurementDescriptor_BasicUnit = 6
)

var MeasurementDescriptor_BasicUnit_name = map[int32]string{
	0: "UNKNOWN",
	1: "SCALAR",
	2: "BITS",
	3: "BYTES",
	4: "SECONDS",
	5: "CORES",
	6: "MAX_UNITS",
}
var MeasurementDescriptor_BasicUnit_value = map[string]int32{
	"UNKNOWN":   0,
	"SCALAR":    1,
	"BITS":      2,
	"BYTES":     3,
	"SECONDS":   4,
	"CORES":     5,
	"MAX_UNITS": 6,
}

func (x MeasurementDescriptor_BasicUnit) String() string {
	return proto.EnumName(MeasurementDescriptor_BasicUnit_name, int32(x))
}
func (MeasurementDescriptor_BasicUnit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorStats, []int{0, 0}
}

// MeasurementDescriptor describes a data point (measurement) type.
type MeasurementDescriptor struct {
	// A descriptive name, e.g. rpc_latency, cpu. Must be unique.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// More detailed description of the resource, used in documentation.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// The units used by this type of measurement.
	Unit *MeasurementDescriptor_MeasurementUnit `protobuf:"bytes,3,opt,name=unit" json:"unit,omitempty"`
}

func (m *MeasurementDescriptor) Reset()                    { *m = MeasurementDescriptor{} }
func (m *MeasurementDescriptor) String() string            { return proto.CompactTextString(m) }
func (*MeasurementDescriptor) ProtoMessage()               {}
func (*MeasurementDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{0} }

func (m *MeasurementDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MeasurementDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MeasurementDescriptor) GetUnit() *MeasurementDescriptor_MeasurementUnit {
	if m != nil {
		return m.Unit
	}
	return nil
}

// MeasurementUnit lets you build compound units of the form
//   10^n * (A * B * ...) / (X * Y * ...),
// where the elements in the numerator and denominator are all BasicUnits.  A
// MeasurementUnit must have at least one BasicUnit in its numerator.
//
// To specify multiplication in the numerator or denominator, simply specify
// multiple numerator or denominator fields.  For example:
//
// - byte-seconds (i.e. bytes * seconds):
//     numerator: BYTES
//     numerator: SECS
//
// - events/sec^2 (i.e. rate of change of events/sec):
//     numerator: SCALAR
//     denominator: SECS
//     denominator: SECS
//
// To specify multiples (in power of 10) of units, specify a non-zero
// 'power10' value, for example:
//
// - MB/s (i.e. megabytes / s):
//     power10: 6
//     numerator: BYTES
//     denominator: SECS
//
// - nanoseconds
//     power10: -9
//     numerator: SECS
type MeasurementDescriptor_MeasurementUnit struct {
	Power10      int32                             `protobuf:"varint,1,opt,name=power10,proto3" json:"power10,omitempty"`
	Numerators   []MeasurementDescriptor_BasicUnit `protobuf:"varint,2,rep,packed,name=numerators,enum=opencensus.proto.stats.MeasurementDescriptor_BasicUnit" json:"numerators,omitempty"`
	Denominators []MeasurementDescriptor_BasicUnit `protobuf:"varint,3,rep,packed,name=denominators,enum=opencensus.proto.stats.MeasurementDescriptor_BasicUnit" json:"denominators,omitempty"`
}

func (m *MeasurementDescriptor_MeasurementUnit) Reset()         { *m = MeasurementDescriptor_MeasurementUnit{} }
func (m *MeasurementDescriptor_MeasurementUnit) String() string { return proto.CompactTextString(m) }
func (*MeasurementDescriptor_MeasurementUnit) ProtoMessage()    {}
func (*MeasurementDescriptor_MeasurementUnit) Descriptor() ([]byte, []int) {
	return fileDescriptorStats, []int{0, 0}
}

func (m *MeasurementDescriptor_MeasurementUnit) GetPower10() int32 {
	if m != nil {
		return m.Power10
	}
	return 0
}

func (m *MeasurementDescriptor_MeasurementUnit) GetNumerators() []MeasurementDescriptor_BasicUnit {
	if m != nil {
		return m.Numerators
	}
	return nil
}

func (m *MeasurementDescriptor_MeasurementUnit) GetDenominators() []MeasurementDescriptor_BasicUnit {
	if m != nil {
		return m.Denominators
	}
	return nil
}

// DistributionAggregation contains summary statistics for a population of
// values and, optionally, a histogram representing the distribution of those
// values across a specified set of histogram buckets, as defined in
// DistributionAggregationDescriptor.bucket_bounds.
//
// The summary statistics are the count, mean, minimum, and the maximum of the
// set of population of values.
//
// Although it is not forbidden, it is generally a bad idea to include
// non-finite values (infinities or NaNs) in the population of values, as this
// will render the `mean` field meaningless.
type DistributionAggregation struct {
	// The number of values in the population. Must be non-negative.
	Count int64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// The arithmetic mean of the values in the population. If `count` is zero
	// then this field must be zero.
	Mean float64 `protobuf:"fixed64,2,opt,name=mean,proto3" json:"mean,omitempty"`
	// The sum of the values in the population.  If `count` is zero then this
	// field must be zero.
	Sum float64 `protobuf:"fixed64,3,opt,name=sum,proto3" json:"sum,omitempty"`
	// The range of the population values. If `count` is zero, this field will not
	// be defined.
	Range *DistributionAggregation_Range `protobuf:"bytes,4,opt,name=range" json:"range,omitempty"`
	// A Distribution may optionally contain a histogram of the values in the
	// population. The histogram is given in `bucket_count` as counts of values
	// that fall into one of a sequence of non-overlapping buckets, as described
	// by `DistributionAggregationDescriptor.bucket_boundaries`. The sum of the
	// values in `bucket_counts` must equal the value in `count`.
	//
	// Bucket counts are given in order under the numbering scheme described
	// above (the underflow bucket has number 0; the finite buckets, if any,
	// have numbers 1 through N-2; the overflow bucket has number N-1).
	//
	// The size of `bucket_count` must be no greater than N as defined in
	// `bucket_boundaries`.
	//
	// Any suffix of trailing zero bucket_count fields may be omitted.
	BucketCounts []int64 `protobuf:"varint,5,rep,packed,name=bucket_counts,json=bucketCounts" json:"bucket_counts,omitempty"`
	// Tags associated with this DistributionAggregation. These will be filled
	// in based on the View specification.
	Tags []*Tag `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *DistributionAggregation) Reset()                    { *m = DistributionAggregation{} }
func (m *DistributionAggregation) String() string            { return proto.CompactTextString(m) }
func (*DistributionAggregation) ProtoMessage()               {}
func (*DistributionAggregation) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{1} }

func (m *DistributionAggregation) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *DistributionAggregation) GetMean() float64 {
	if m != nil {
		return m.Mean
	}
	return 0
}

func (m *DistributionAggregation) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *DistributionAggregation) GetRange() *DistributionAggregation_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *DistributionAggregation) GetBucketCounts() []int64 {
	if m != nil {
		return m.BucketCounts
	}
	return nil
}

func (m *DistributionAggregation) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Describes a range of population values.
type DistributionAggregation_Range struct {
	// The minimum of the population values.
	Min float64 `protobuf:"fixed64,1,opt,name=min,proto3" json:"min,omitempty"`
	// The maximum of the population values.
	Max float64 `protobuf:"fixed64,2,opt,name=max,proto3" json:"max,omitempty"`
}

func (m *DistributionAggregation_Range) Reset()         { *m = DistributionAggregation_Range{} }
func (m *DistributionAggregation_Range) String() string { return proto.CompactTextString(m) }
func (*DistributionAggregation_Range) ProtoMessage()    {}
func (*DistributionAggregation_Range) Descriptor() ([]byte, []int) {
	return fileDescriptorStats, []int{1, 0}
}

func (m *DistributionAggregation_Range) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *DistributionAggregation_Range) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

type DistributionAggregationDescriptor struct {
	// A Distribution may optionally contain a histogram of the values in the
	// population. The bucket boundaries for that histogram are described by
	// `bucket_bounds`. This defines `size(bucket_bounds) + 1` (= N)
	// buckets. The boundaries for bucket index i are:
	//
	// [-infinity, bucket_bounds[i]) for i == 0
	// [bucket_bounds[i-1], bucket_bounds[i]) for 0 < i < N-2
	// [bucket_bounds[i-1], +infinity) for i == N-1
	//
	// i.e. an underflow bucket (number 0), zero or more finite buckets (1
	// through N - 2, and an overflow bucket (N - 1), with inclusive lower
	// bounds and exclusive upper bounds.
	//
	// If `bucket_bounds` has no elements (zero size), then there is no
	// histogram associated with the Distribution. If `bucket_bounds` has only
	// one element, there are no finite buckets, and that single element is the
	// common boundary of the overflow and underflow buckets. The values must
	// be monotonically increasing.
	BucketBounds []float64 `protobuf:"fixed64,1,rep,packed,name=bucket_bounds,json=bucketBounds" json:"bucket_bounds,omitempty"`
}

func (m *DistributionAggregationDescriptor) Reset()         { *m = DistributionAggregationDescriptor{} }
func (m *DistributionAggregationDescriptor) String() string { return proto.CompactTextString(m) }
func (*DistributionAggregationDescriptor) ProtoMessage()    {}
func (*DistributionAggregationDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptorStats, []int{2}
}

func (m *DistributionAggregationDescriptor) GetBucketBounds() []float64 {
	if m != nil {
		return m.BucketBounds
	}
	return nil
}

// An IntervalAggreation records summary stats over various time
// windows. These stats are approximate, with the degree of accuracy
// controlled by setting the n_sub_intervals parameter in the
// IntervalAggregationDescriptor.
type IntervalAggregation struct {
	// Full set of intervals for this aggregation.
	Intervals []*IntervalAggregation_Interval `protobuf:"bytes,1,rep,name=intervals" json:"intervals,omitempty"`
	// Tags associated with this IntervalAggregation. These will be filled in
	// based on the View specification.
	Tags []*Tag `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *IntervalAggregation) Reset()                    { *m = IntervalAggregation{} }
func (m *IntervalAggregation) String() string            { return proto.CompactTextString(m) }
func (*IntervalAggregation) ProtoMessage()               {}
func (*IntervalAggregation) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{3} }

func (m *IntervalAggregation) GetIntervals() []*IntervalAggregation_Interval {
	if m != nil {
		return m.Intervals
	}
	return nil
}

func (m *IntervalAggregation) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Summary statistic over a single time interval.
type IntervalAggregation_Interval struct {
	// The interval duration. Must be positive.
	IntervalSize *google_protobuf.Duration `protobuf:"bytes,1,opt,name=interval_size,json=intervalSize" json:"interval_size,omitempty"`
	// Approximate number of measurements recorded in this interval.
	Count float64 `protobuf:"fixed64,2,opt,name=count,proto3" json:"count,omitempty"`
	// The cumulative sum of measurements in this interval.
	Sum float64 `protobuf:"fixed64,3,opt,name=sum,proto3" json:"sum,omitempty"`
}

func (m *IntervalAggregation_Interval) Reset()         { *m = IntervalAggregation_Interval{} }
func (m *IntervalAggregation_Interval) String() string { return proto.CompactTextString(m) }
func (*IntervalAggregation_Interval) ProtoMessage()    {}
func (*IntervalAggregation_Interval) Descriptor() ([]byte, []int) {
	return fileDescriptorStats, []int{3, 0}
}

func (m *IntervalAggregation_Interval) GetIntervalSize() *google_protobuf.Duration {
	if m != nil {
		return m.IntervalSize
	}
	return nil
}

func (m *IntervalAggregation_Interval) GetCount() float64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *IntervalAggregation_Interval) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

// An IntervalAggreationDescriptor specifies time intervals for an
// IntervalAggregation.
type IntervalAggregationDescriptor struct {
	// Number of internal sub-intervals to use when collecting stats for each
	// interval. The max error in interval measurements will be approximately
	// 1/n_sub_intervals (although in practice, this will only be approached in
	// the presence of very large and bursty workload changes), and underlying
	// memory usage will be roughly proportional to the value of this
	// field. Must be in the range [2, 20]. A value of 5 will be used if this is
	// unspecified.
	NSubIntervals int32 `protobuf:"varint,1,opt,name=n_sub_intervals,json=nSubIntervals,proto3" json:"n_sub_intervals,omitempty"`
	// The size of each interval, as a time duration. Must have at least one
	// element.
	IntervalSizes []*google_protobuf.Duration `protobuf:"bytes,2,rep,name=interval_sizes,json=intervalSizes" json:"interval_sizes,omitempty"`
}

func (m *IntervalAggregationDescriptor) Reset()         { *m = IntervalAggregationDescriptor{} }
func (m *IntervalAggregationDescriptor) String() string { return proto.CompactTextString(m) }
func (*IntervalAggregationDescriptor) ProtoMessage()    {}
func (*IntervalAggregationDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptorStats, []int{4}
}

func (m *IntervalAggregationDescriptor) GetNSubIntervals() int32 {
	if m != nil {
		return m.NSubIntervals
	}
	return 0
}

func (m *IntervalAggregationDescriptor) GetIntervalSizes() []*google_protobuf.Duration {
	if m != nil {
		return m.IntervalSizes
	}
	return nil
}

// A Tag: key-value pair.
// Both strings must be printable ASCII.
type Tag struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{5} }

func (m *Tag) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Tag) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A ViewDescriptor specifies an AggregationDescriptor and a set of tag
// keys. Views instantiated from this descriptor will contain Aggregations
// broken down by the unique set of matching tag values for each measurement.
type ViewDescriptor struct {
	// Name of view. Must be unique.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// More detailed description, for documentation purposes.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Name of a MeasurementDescriptor to be used for this view.
	MeasurementDescriptorName string `protobuf:"bytes,3,opt,name=measurement_descriptor_name,json=measurementDescriptorName,proto3" json:"measurement_descriptor_name,omitempty"`
	// Aggregation type to associate with View.
	//
	// Types that are valid to be assigned to Aggregation:
	//	*ViewDescriptor_IntervalAggregation
	//	*ViewDescriptor_DistributionAggregation
	Aggregation isViewDescriptor_Aggregation `protobuf_oneof:"aggregation"`
	// Tag keys to match with a given measurement. If no keys are specified,
	// then all stats are recorded. Keys must be unique.
	TagKeys []string `protobuf:"bytes,6,rep,name=tag_keys,json=tagKeys" json:"tag_keys,omitempty"`
}

func (m *ViewDescriptor) Reset()                    { *m = ViewDescriptor{} }
func (m *ViewDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ViewDescriptor) ProtoMessage()               {}
func (*ViewDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{6} }

type isViewDescriptor_Aggregation interface {
	isViewDescriptor_Aggregation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ViewDescriptor_IntervalAggregation struct {
	IntervalAggregation *IntervalAggregationDescriptor `protobuf:"bytes,4,opt,name=interval_aggregation,json=intervalAggregation,oneof"`
}
type ViewDescriptor_DistributionAggregation struct {
	DistributionAggregation *DistributionAggregationDescriptor `protobuf:"bytes,5,opt,name=distribution_aggregation,json=distributionAggregation,oneof"`
}

func (*ViewDescriptor_IntervalAggregation) isViewDescriptor_Aggregation()     {}
func (*ViewDescriptor_DistributionAggregation) isViewDescriptor_Aggregation() {}

func (m *ViewDescriptor) GetAggregation() isViewDescriptor_Aggregation {
	if m != nil {
		return m.Aggregation
	}
	return nil
}

func (m *ViewDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ViewDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ViewDescriptor) GetMeasurementDescriptorName() string {
	if m != nil {
		return m.MeasurementDescriptorName
	}
	return ""
}

func (m *ViewDescriptor) GetIntervalAggregation() *IntervalAggregationDescriptor {
	if x, ok := m.GetAggregation().(*ViewDescriptor_IntervalAggregation); ok {
		return x.IntervalAggregation
	}
	return nil
}

func (m *ViewDescriptor) GetDistributionAggregation() *DistributionAggregationDescriptor {
	if x, ok := m.GetAggregation().(*ViewDescriptor_DistributionAggregation); ok {
		return x.DistributionAggregation
	}
	return nil
}

func (m *ViewDescriptor) GetTagKeys() []string {
	if m != nil {
		return m.TagKeys
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ViewDescriptor) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ViewDescriptor_OneofMarshaler, _ViewDescriptor_OneofUnmarshaler, _ViewDescriptor_OneofSizer, []interface{}{
		(*ViewDescriptor_IntervalAggregation)(nil),
		(*ViewDescriptor_DistributionAggregation)(nil),
	}
}

func _ViewDescriptor_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ViewDescriptor)
	// aggregation
	switch x := m.Aggregation.(type) {
	case *ViewDescriptor_IntervalAggregation:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntervalAggregation); err != nil {
			return err
		}
	case *ViewDescriptor_DistributionAggregation:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DistributionAggregation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ViewDescriptor.Aggregation has unexpected type %T", x)
	}
	return nil
}

func _ViewDescriptor_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ViewDescriptor)
	switch tag {
	case 4: // aggregation.interval_aggregation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntervalAggregationDescriptor)
		err := b.DecodeMessage(msg)
		m.Aggregation = &ViewDescriptor_IntervalAggregation{msg}
		return true, err
	case 5: // aggregation.distribution_aggregation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DistributionAggregationDescriptor)
		err := b.DecodeMessage(msg)
		m.Aggregation = &ViewDescriptor_DistributionAggregation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ViewDescriptor_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ViewDescriptor)
	// aggregation
	switch x := m.Aggregation.(type) {
	case *ViewDescriptor_IntervalAggregation:
		s := proto.Size(x.IntervalAggregation)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ViewDescriptor_DistributionAggregation:
		s := proto.Size(x.DistributionAggregation)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DistributionView contains all aggregations for a view specified using a
// DistributionAggregationDescriptor.
type DistributionView struct {
	// Aggregations - each will have a unique set of tag values for the tag_keys
	// associated with the corresponding View.
	Aggregations []*DistributionAggregation `protobuf:"bytes,1,rep,name=aggregations" json:"aggregations,omitempty"`
	// Start and end timestamps over which aggregations was accumulated.
	Start *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=start" json:"start,omitempty"`
	End   *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
}

func (m *DistributionView) Reset()                    { *m = DistributionView{} }
func (m *DistributionView) String() string            { return proto.CompactTextString(m) }
func (*DistributionView) ProtoMessage()               {}
func (*DistributionView) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{7} }

func (m *DistributionView) GetAggregations() []*DistributionAggregation {
	if m != nil {
		return m.Aggregations
	}
	return nil
}

func (m *DistributionView) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *DistributionView) GetEnd() *google_protobuf1.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

// IntervalView contains all aggregations for a view specified using a
// IntervalAggregationDescriptor.
type IntervalView struct {
	// Aggregations - each will have a unique set of tag values for the tag_keys
	// associated with the corresponding View.
	Aggregations []*IntervalAggregation `protobuf:"bytes,1,rep,name=aggregations" json:"aggregations,omitempty"`
}

func (m *IntervalView) Reset()                    { *m = IntervalView{} }
func (m *IntervalView) String() string            { return proto.CompactTextString(m) }
func (*IntervalView) ProtoMessage()               {}
func (*IntervalView) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{8} }

func (m *IntervalView) GetAggregations() []*IntervalAggregation {
	if m != nil {
		return m.Aggregations
	}
	return nil
}

// A View contains the aggregations based on a ViewDescriptor.
type View struct {
	// ViewDescriptor name associated with this set of View.
	ViewName string `protobuf:"bytes,1,opt,name=view_name,json=viewName,proto3" json:"view_name,omitempty"`
	// Types that are valid to be assigned to View:
	//	*View_DistributionView
	//	*View_IntervalView
	View isView_View `protobuf_oneof:"view"`
}

func (m *View) Reset()                    { *m = View{} }
func (m *View) String() string            { return proto.CompactTextString(m) }
func (*View) ProtoMessage()               {}
func (*View) Descriptor() ([]byte, []int) { return fileDescriptorStats, []int{9} }

type isView_View interface {
	isView_View()
	MarshalTo([]byte) (int, error)
	Size() int
}

type View_DistributionView struct {
	DistributionView *DistributionView `protobuf:"bytes,2,opt,name=distribution_view,json=distributionView,oneof"`
}
type View_IntervalView struct {
	IntervalView *IntervalView `protobuf:"bytes,3,opt,name=interval_view,json=intervalView,oneof"`
}

func (*View_DistributionView) isView_View() {}
func (*View_IntervalView) isView_View()     {}

func (m *View) GetView() isView_View {
	if m != nil {
		return m.View
	}
	return nil
}

func (m *View) GetViewName() string {
	if m != nil {
		return m.ViewName
	}
	return ""
}

func (m *View) GetDistributionView() *DistributionView {
	if x, ok := m.GetView().(*View_DistributionView); ok {
		return x.DistributionView
	}
	return nil
}

func (m *View) GetIntervalView() *IntervalView {
	if x, ok := m.GetView().(*View_IntervalView); ok {
		return x.IntervalView
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*View) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _View_OneofMarshaler, _View_OneofUnmarshaler, _View_OneofSizer, []interface{}{
		(*View_DistributionView)(nil),
		(*View_IntervalView)(nil),
	}
}

func _View_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*View)
	// view
	switch x := m.View.(type) {
	case *View_DistributionView:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DistributionView); err != nil {
			return err
		}
	case *View_IntervalView:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntervalView); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("View.View has unexpected type %T", x)
	}
	return nil
}

func _View_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*View)
	switch tag {
	case 2: // view.distribution_view
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DistributionView)
		err := b.DecodeMessage(msg)
		m.View = &View_DistributionView{msg}
		return true, err
	case 3: // view.interval_view
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntervalView)
		err := b.DecodeMessage(msg)
		m.View = &View_IntervalView{msg}
		return true, err
	default:
		return false, nil
	}
}

func _View_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*View)
	// view
	switch x := m.View.(type) {
	case *View_DistributionView:
		s := proto.Size(x.DistributionView)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *View_IntervalView:
		s := proto.Size(x.IntervalView)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*MeasurementDescriptor)(nil), "opencensus.proto.stats.MeasurementDescriptor")
	proto.RegisterType((*MeasurementDescriptor_MeasurementUnit)(nil), "opencensus.proto.stats.MeasurementDescriptor.MeasurementUnit")
	proto.RegisterType((*DistributionAggregation)(nil), "opencensus.proto.stats.DistributionAggregation")
	proto.RegisterType((*DistributionAggregation_Range)(nil), "opencensus.proto.stats.DistributionAggregation.Range")
	proto.RegisterType((*DistributionAggregationDescriptor)(nil), "opencensus.proto.stats.DistributionAggregationDescriptor")
	proto.RegisterType((*IntervalAggregation)(nil), "opencensus.proto.stats.IntervalAggregation")
	proto.RegisterType((*IntervalAggregation_Interval)(nil), "opencensus.proto.stats.IntervalAggregation.Interval")
	proto.RegisterType((*IntervalAggregationDescriptor)(nil), "opencensus.proto.stats.IntervalAggregationDescriptor")
	proto.RegisterType((*Tag)(nil), "opencensus.proto.stats.Tag")
	proto.RegisterType((*ViewDescriptor)(nil), "opencensus.proto.stats.ViewDescriptor")
	proto.RegisterType((*DistributionView)(nil), "opencensus.proto.stats.DistributionView")
	proto.RegisterType((*IntervalView)(nil), "opencensus.proto.stats.IntervalView")
	proto.RegisterType((*View)(nil), "opencensus.proto.stats.View")
	proto.RegisterEnum("opencensus.proto.stats.MeasurementDescriptor_BasicUnit", MeasurementDescriptor_BasicUnit_name, MeasurementDescriptor_BasicUnit_value)
}
func (m *MeasurementDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasurementDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Unit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.Unit.Size()))
		n1, err := m.Unit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *MeasurementDescriptor_MeasurementUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasurementDescriptor_MeasurementUnit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Power10 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.Power10))
	}
	if len(m.Numerators) > 0 {
		dAtA3 := make([]byte, len(m.Numerators)*10)
		var j2 int
		for _, num := range m.Numerators {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStats(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Denominators) > 0 {
		dAtA5 := make([]byte, len(m.Denominators)*10)
		var j4 int
		for _, num := range m.Denominators {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStats(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *DistributionAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributionAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.Count))
	}
	if m.Mean != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mean))))
		i += 8
	}
	if m.Sum != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i += 8
	}
	if m.Range != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.Range.Size()))
		n6, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.BucketCounts) > 0 {
		dAtA8 := make([]byte, len(m.BucketCounts)*10)
		var j7 int
		for _, num1 := range m.BucketCounts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStats(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DistributionAggregation_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributionAggregation_Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Min != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
		i += 8
	}
	if m.Max != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
		i += 8
	}
	return i, nil
}

func (m *DistributionAggregationDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributionAggregationDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BucketBounds) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.BucketBounds)*8))
		for _, num := range m.BucketBounds {
			f9 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f9))
			i += 8
		}
	}
	return i, nil
}

func (m *IntervalAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Intervals) > 0 {
		for _, msg := range m.Intervals {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IntervalAggregation_Interval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalAggregation_Interval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IntervalSize != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.IntervalSize.Size()))
		n10, err := m.IntervalSize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Count != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Count))))
		i += 8
	}
	if m.Sum != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i += 8
	}
	return i, nil
}

func (m *IntervalAggregationDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalAggregationDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NSubIntervals != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.NSubIntervals))
	}
	if len(m.IntervalSizes) > 0 {
		for _, msg := range m.IntervalSizes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *ViewDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.MeasurementDescriptorName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.MeasurementDescriptorName)))
		i += copy(dAtA[i:], m.MeasurementDescriptorName)
	}
	if m.Aggregation != nil {
		nn11, err := m.Aggregation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if len(m.TagKeys) > 0 {
		for _, s := range m.TagKeys {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ViewDescriptor_IntervalAggregation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IntervalAggregation != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.IntervalAggregation.Size()))
		n12, err := m.IntervalAggregation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *ViewDescriptor_DistributionAggregation) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DistributionAggregation != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.DistributionAggregation.Size()))
		n13, err := m.DistributionAggregation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *DistributionView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributionView) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aggregations) > 0 {
		for _, msg := range m.Aggregations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Start != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.Start.Size()))
		n14, err := m.Start.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.End != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.End.Size()))
		n15, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *IntervalView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntervalView) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aggregations) > 0 {
		for _, msg := range m.Aggregations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *View) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ViewName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStats(dAtA, i, uint64(len(m.ViewName)))
		i += copy(dAtA[i:], m.ViewName)
	}
	if m.View != nil {
		nn16, err := m.View.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	return i, nil
}

func (m *View_DistributionView) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DistributionView != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.DistributionView.Size()))
		n17, err := m.DistributionView.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *View_IntervalView) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IntervalView != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStats(dAtA, i, uint64(m.IntervalView.Size()))
		n18, err := m.IntervalView.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func encodeVarintStats(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MeasurementDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	if m.Unit != nil {
		l = m.Unit.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}

func (m *MeasurementDescriptor_MeasurementUnit) Size() (n int) {
	var l int
	_ = l
	if m.Power10 != 0 {
		n += 1 + sovStats(uint64(m.Power10))
	}
	if len(m.Numerators) > 0 {
		l = 0
		for _, e := range m.Numerators {
			l += sovStats(uint64(e))
		}
		n += 1 + sovStats(uint64(l)) + l
	}
	if len(m.Denominators) > 0 {
		l = 0
		for _, e := range m.Denominators {
			l += sovStats(uint64(e))
		}
		n += 1 + sovStats(uint64(l)) + l
	}
	return n
}

func (m *DistributionAggregation) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovStats(uint64(m.Count))
	}
	if m.Mean != 0 {
		n += 9
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	if len(m.BucketCounts) > 0 {
		l = 0
		for _, e := range m.BucketCounts {
			l += sovStats(uint64(e))
		}
		n += 1 + sovStats(uint64(l)) + l
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovStats(uint64(l))
		}
	}
	return n
}

func (m *DistributionAggregation_Range) Size() (n int) {
	var l int
	_ = l
	if m.Min != 0 {
		n += 9
	}
	if m.Max != 0 {
		n += 9
	}
	return n
}

func (m *DistributionAggregationDescriptor) Size() (n int) {
	var l int
	_ = l
	if len(m.BucketBounds) > 0 {
		n += 1 + sovStats(uint64(len(m.BucketBounds)*8)) + len(m.BucketBounds)*8
	}
	return n
}

func (m *IntervalAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Intervals) > 0 {
		for _, e := range m.Intervals {
			l = e.Size()
			n += 1 + l + sovStats(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovStats(uint64(l))
		}
	}
	return n
}

func (m *IntervalAggregation_Interval) Size() (n int) {
	var l int
	_ = l
	if m.IntervalSize != nil {
		l = m.IntervalSize.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	if m.Count != 0 {
		n += 9
	}
	if m.Sum != 0 {
		n += 9
	}
	return n
}

func (m *IntervalAggregationDescriptor) Size() (n int) {
	var l int
	_ = l
	if m.NSubIntervals != 0 {
		n += 1 + sovStats(uint64(m.NSubIntervals))
	}
	if len(m.IntervalSizes) > 0 {
		for _, e := range m.IntervalSizes {
			l = e.Size()
			n += 1 + l + sovStats(uint64(l))
		}
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}

func (m *ViewDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	l = len(m.MeasurementDescriptorName)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	if m.Aggregation != nil {
		n += m.Aggregation.Size()
	}
	if len(m.TagKeys) > 0 {
		for _, s := range m.TagKeys {
			l = len(s)
			n += 1 + l + sovStats(uint64(l))
		}
	}
	return n
}

func (m *ViewDescriptor_IntervalAggregation) Size() (n int) {
	var l int
	_ = l
	if m.IntervalAggregation != nil {
		l = m.IntervalAggregation.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}
func (m *ViewDescriptor_DistributionAggregation) Size() (n int) {
	var l int
	_ = l
	if m.DistributionAggregation != nil {
		l = m.DistributionAggregation.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}
func (m *DistributionView) Size() (n int) {
	var l int
	_ = l
	if len(m.Aggregations) > 0 {
		for _, e := range m.Aggregations {
			l = e.Size()
			n += 1 + l + sovStats(uint64(l))
		}
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}

func (m *IntervalView) Size() (n int) {
	var l int
	_ = l
	if len(m.Aggregations) > 0 {
		for _, e := range m.Aggregations {
			l = e.Size()
			n += 1 + l + sovStats(uint64(l))
		}
	}
	return n
}

func (m *View) Size() (n int) {
	var l int
	_ = l
	l = len(m.ViewName)
	if l > 0 {
		n += 1 + l + sovStats(uint64(l))
	}
	if m.View != nil {
		n += m.View.Size()
	}
	return n
}

func (m *View_DistributionView) Size() (n int) {
	var l int
	_ = l
	if m.DistributionView != nil {
		l = m.DistributionView.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}
func (m *View_IntervalView) Size() (n int) {
	var l int
	_ = l
	if m.IntervalView != nil {
		l = m.IntervalView.Size()
		n += 1 + l + sovStats(uint64(l))
	}
	return n
}

func sovStats(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStats(x uint64) (n int) {
	return sovStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MeasurementDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasurementDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasurementDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unit == nil {
				m.Unit = &MeasurementDescriptor_MeasurementUnit{}
			}
			if err := m.Unit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasurementDescriptor_MeasurementUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasurementUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasurementUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power10", wireType)
			}
			m.Power10 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power10 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v MeasurementDescriptor_BasicUnit
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (MeasurementDescriptor_BasicUnit(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Numerators = append(m.Numerators, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStats
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v MeasurementDescriptor_BasicUnit
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (MeasurementDescriptor_BasicUnit(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Numerators = append(m.Numerators, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerators", wireType)
			}
		case 3:
			if wireType == 0 {
				var v MeasurementDescriptor_BasicUnit
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (MeasurementDescriptor_BasicUnit(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Denominators = append(m.Denominators, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStats
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v MeasurementDescriptor_BasicUnit
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (MeasurementDescriptor_BasicUnit(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Denominators = append(m.Denominators, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominators", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributionAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributionAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributionAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mean = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &DistributionAggregation_Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BucketCounts = append(m.BucketCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStats
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BucketCounts = append(m.BucketCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketCounts", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributionAggregation_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributionAggregationDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributionAggregationDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributionAggregationDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.BucketBounds = append(m.BucketBounds, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStats
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.BucketBounds = append(m.BucketBounds, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketBounds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intervals = append(m.Intervals, &IntervalAggregation_Interval{})
			if err := m.Intervals[len(m.Intervals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalAggregation_Interval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IntervalSize == nil {
				m.IntervalSize = &google_protobuf.Duration{}
			}
			if err := m.IntervalSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalAggregationDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalAggregationDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalAggregationDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NSubIntervals", wireType)
			}
			m.NSubIntervals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NSubIntervals |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntervalSizes = append(m.IntervalSizes, &google_protobuf.Duration{})
			if err := m.IntervalSizes[len(m.IntervalSizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementDescriptorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementDescriptorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntervalAggregationDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Aggregation = &ViewDescriptor_IntervalAggregation{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DistributionAggregationDescriptor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Aggregation = &ViewDescriptor_DistributionAggregation{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagKeys = append(m.TagKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributionView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributionView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributionView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregations = append(m.Aggregations, &DistributionAggregation{})
			if err := m.Aggregations[len(m.Aggregations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &google_protobuf1.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &google_protobuf1.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntervalView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntervalView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntervalView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregations = append(m.Aggregations, &IntervalAggregation{})
			if err := m.Aggregations[len(m.Aggregations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DistributionView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.View = &View_DistributionView{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntervalView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.View = &View_IntervalView{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStats
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStats
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStats(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStats = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStats   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("opencensus/proto/stats/stats.proto", fileDescriptorStats) }

var fileDescriptorStats = []byte{
	// 938 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0xe3, 0xa4, 0x6d, 0x4e, 0x92, 0x6e, 0x98, 0x5d, 0x58, 0x37, 0x15, 0x21, 0x18, 0x84,
	0x22, 0x2d, 0x24, 0x4b, 0x00, 0xa1, 0xbd, 0x60, 0x45, 0xd3, 0x56, 0x6a, 0x55, 0x36, 0x5d, 0xc6,
	0x29, 0x05, 0x71, 0x61, 0x26, 0xf1, 0x60, 0x99, 0xd6, 0xe3, 0xc8, 0x33, 0x6e, 0xe9, 0xbe, 0x01,
	0x37, 0x88, 0x0b, 0x5e, 0x81, 0x67, 0x81, 0x4b, 0x78, 0x03, 0x28, 0x12, 0xcf, 0x81, 0x66, 0xc6,
	0x4e, 0x9c, 0x6e, 0xd2, 0xdd, 0x6a, 0x6f, 0x92, 0x99, 0x73, 0xce, 0x7c, 0xe7, 0x3b, 0xbf, 0x06,
	0x3b, 0x9a, 0x50, 0x36, 0xa6, 0x8c, 0x27, 0xbc, 0x3b, 0x89, 0x23, 0x11, 0x75, 0xb9, 0x20, 0x82,
	0xeb, 0xdf, 0x8e, 0x92, 0xa0, 0x37, 0x66, 0x36, 0x5a, 0xd2, 0x51, 0xda, 0x46, 0xd3, 0x8f, 0x22,
	0xff, 0x8c, 0xea, 0x77, 0xa3, 0xe4, 0xfb, 0xae, 0x97, 0xc4, 0x44, 0x04, 0x11, 0xd3, 0x56, 0x8d,
	0xb7, 0xae, 0xeb, 0x45, 0x10, 0x52, 0x2e, 0x48, 0x38, 0xd1, 0x06, 0xf6, 0x7f, 0x26, 0xbc, 0xfe,
	0x84, 0x12, 0x9e, 0xc4, 0x34, 0xa4, 0x4c, 0xec, 0x52, 0x3e, 0x8e, 0x83, 0x89, 0x88, 0x62, 0x84,
	0xa0, 0xc8, 0x48, 0x48, 0x2d, 0xa3, 0x65, 0xb4, 0xcb, 0x58, 0x9d, 0x51, 0x0b, 0x2a, 0x5e, 0x6a,
	0x11, 0x44, 0xcc, 0x2a, 0x28, 0x55, 0x5e, 0x84, 0xbe, 0x84, 0x62, 0xc2, 0x02, 0x61, 0x99, 0x2d,
	0xa3, 0x5d, 0xe9, 0x7d, 0xd6, 0x59, 0xcc, 0xbb, 0xb3, 0xd0, 0x65, 0x5e, 0x7a, 0xcc, 0x02, 0x81,
	0x15, 0x54, 0xe3, 0x1f, 0x03, 0xee, 0x5c, 0xd3, 0x20, 0x0b, 0xd6, 0x26, 0xd1, 0x05, 0x8d, 0x3f,
	0x7c, 0xa8, 0xf8, 0x95, 0x70, 0x76, 0x45, 0x27, 0x00, 0x2c, 0x09, 0x69, 0x4c, 0x44, 0x14, 0x73,
	0xab, 0xd0, 0x32, 0xdb, 0x1b, 0xbd, 0x4f, 0x6f, 0x47, 0xa3, 0x4f, 0x78, 0x30, 0x56, 0x04, 0x72,
	0x50, 0xe8, 0x5b, 0xa8, 0x7a, 0x94, 0x45, 0x61, 0xc0, 0x34, 0xb4, 0xf9, 0x6a, 0xd0, 0x73, 0x60,
	0xf6, 0x77, 0x50, 0x9e, 0xaa, 0x50, 0x05, 0xd6, 0x8e, 0x07, 0x87, 0x83, 0xa3, 0x93, 0x41, 0x7d,
	0x05, 0x01, 0xac, 0x3a, 0x3b, 0xdb, 0x5f, 0x6c, 0xe3, 0xba, 0x81, 0xd6, 0xa1, 0xd8, 0x3f, 0x18,
	0x3a, 0xf5, 0x02, 0x2a, 0x43, 0xa9, 0xff, 0xcd, 0x70, 0xcf, 0xa9, 0x9b, 0xd2, 0xda, 0xd9, 0xdb,
	0x39, 0x1a, 0xec, 0x3a, 0xf5, 0xa2, 0x94, 0xef, 0x1c, 0xe1, 0x3d, 0xa7, 0x5e, 0x42, 0x35, 0x28,
	0x3f, 0xd9, 0xfe, 0xda, 0x3d, 0x1e, 0xc8, 0x17, 0xab, 0xf6, 0x6f, 0x05, 0xb8, 0xbf, 0x1b, 0x70,
	0x11, 0x07, 0xa3, 0x44, 0x56, 0x6a, 0xdb, 0xf7, 0x63, 0xea, 0xab, 0x5e, 0x41, 0xf7, 0xa0, 0x34,
	0x8e, 0x12, 0x26, 0x54, 0x2e, 0x4d, 0xac, 0x2f, 0xb2, 0x01, 0x42, 0x4a, 0x74, 0x95, 0x0d, 0xac,
	0xce, 0xa8, 0x0e, 0x26, 0x4f, 0x42, 0x55, 0x5d, 0x03, 0xcb, 0x23, 0x3a, 0x84, 0x52, 0x4c, 0x98,
	0x4f, 0xad, 0xa2, 0xaa, 0xf8, 0x27, 0xcb, 0xf2, 0xb1, 0xc4, 0x77, 0x07, 0xcb, 0xc7, 0x58, 0x63,
	0xa0, 0x77, 0xa0, 0x36, 0x4a, 0xc6, 0xa7, 0x54, 0xb8, 0x8a, 0x02, 0xb7, 0x4a, 0x2d, 0xb3, 0x6d,
	0xe2, 0xaa, 0x16, 0xee, 0x28, 0x19, 0xea, 0x42, 0x51, 0x10, 0x9f, 0x5b, 0xab, 0x2d, 0xb3, 0x5d,
	0xe9, 0x6d, 0x2d, 0x73, 0x38, 0x24, 0x3e, 0x56, 0x86, 0x8d, 0x07, 0x50, 0x52, 0x5e, 0x24, 0xfb,
	0x30, 0x60, 0x2a, 0x4a, 0x03, 0xcb, 0xa3, 0x92, 0x90, 0x1f, 0xd3, 0x10, 0xe5, 0xd1, 0xde, 0x87,
	0xb7, 0x97, 0x50, 0xcd, 0xcd, 0xc6, 0x8c, 0xe7, 0x28, 0x4a, 0x98, 0xc7, 0x2d, 0xa3, 0x65, 0xb6,
	0x8d, 0x8c, 0x67, 0x5f, 0xc9, 0xec, 0x9f, 0x0b, 0x70, 0xf7, 0x80, 0x09, 0x1a, 0x9f, 0x93, 0xb3,
	0x7c, 0xb6, 0x31, 0x94, 0x83, 0x54, 0xac, 0x1f, 0x56, 0x7a, 0x1f, 0x2f, 0x0b, 0x62, 0xc1, 0xfb,
	0xa9, 0x0c, 0xcf, 0x60, 0xa6, 0x39, 0x29, 0xbc, 0x6c, 0x4e, 0x62, 0x58, 0xcf, 0x70, 0xd0, 0x63,
	0xa8, 0x65, 0x48, 0x2e, 0x0f, 0x9e, 0xe9, 0x91, 0xaf, 0xf4, 0x36, 0x3b, 0x7a, 0x79, 0x74, 0xb2,
	0xe5, 0xd1, 0xd9, 0x4d, 0x97, 0x0b, 0xae, 0x66, 0xf6, 0x4e, 0xf0, 0x8c, 0xce, 0xda, 0x47, 0xa7,
	0x31, 0x6d, 0x9f, 0xe7, 0x5a, 0xc5, 0xfe, 0xc9, 0x80, 0x37, 0x17, 0x04, 0x94, 0xcb, 0xeb, 0x7b,
	0x70, 0x87, 0xb9, 0x3c, 0x19, 0xb9, 0xf9, 0x04, 0xc9, 0xf1, 0xae, 0x31, 0x27, 0x19, 0x1d, 0x4c,
	0xc3, 0xfd, 0x1c, 0x36, 0xe6, 0x18, 0x67, 0x81, 0xdf, 0x40, 0xb9, 0x96, 0xa7, 0xcc, 0xed, 0x0f,
	0xc0, 0x1c, 0x12, 0x5f, 0x92, 0x3c, 0xa5, 0x97, 0xe9, 0x8e, 0x93, 0x47, 0x19, 0xcc, 0x39, 0x39,
	0x4b, 0x68, 0xba, 0xdc, 0xf4, 0xc5, 0xfe, 0xd5, 0x84, 0x8d, 0xaf, 0x02, 0x7a, 0xf1, 0xca, 0xfb,
	0xf1, 0x31, 0x6c, 0x85, 0xb3, 0xcd, 0xe0, 0x7a, 0x53, 0x3c, 0x57, 0x81, 0x99, 0xea, 0xc5, 0x66,
	0xb8, 0x68, 0x79, 0x0c, 0xa4, 0x87, 0x1f, 0xe0, 0xde, 0x34, 0x72, 0x32, 0xcb, 0xe1, 0x8b, 0xa6,
	0xef, 0xc6, 0xb4, 0xef, 0xaf, 0xe0, 0xbb, 0xc1, 0x82, 0x46, 0x3d, 0x07, 0xcb, 0xcb, 0x8d, 0xc2,
	0x9c, 0xbf, 0x92, 0xf2, 0xf7, 0xe8, 0x96, 0xd3, 0x3e, 0xe7, 0xf3, 0xbe, 0xb7, 0x64, 0x1d, 0x6d,
	0xc2, 0xba, 0x20, 0xbe, 0x7b, 0x4a, 0x2f, 0xf5, 0x90, 0x97, 0xf1, 0x9a, 0x20, 0xfe, 0x21, 0xbd,
	0xe4, 0xfd, 0x1a, 0x54, 0x72, 0x2c, 0xec, 0xdf, 0x0d, 0xa8, 0xe7, 0x5d, 0xc9, 0x12, 0x21, 0x07,
	0xaa, 0x39, 0x9b, 0x6c, 0xc4, 0xba, 0xb7, 0xa4, 0x8a, 0xe7, 0x40, 0xd0, 0x43, 0x28, 0x71, 0x41,
	0x62, 0xdd, 0xe3, 0x95, 0x5e, 0xe3, 0xb9, 0x46, 0x1b, 0x66, 0x1f, 0x56, 0xac, 0x0d, 0xd1, 0xfb,
	0x60, 0x52, 0xe6, 0xa5, 0x1f, 0xc2, 0x9b, 0xec, 0xa5, 0x99, 0xed, 0x42, 0x35, 0xab, 0x91, 0x0a,
	0xe2, 0x68, 0x61, 0x10, 0x0f, 0x6e, 0x51, 0xdf, 0xf9, 0x00, 0xec, 0xbf, 0x0c, 0x28, 0x2a, 0xe4,
	0x2d, 0x28, 0x9f, 0x07, 0xf4, 0xc2, 0xcd, 0x35, 0xef, 0xba, 0x14, 0xa8, 0xf6, 0x3a, 0x81, 0xd7,
	0xe6, 0x4a, 0x2e, 0x15, 0x69, 0xc8, 0xed, 0x97, 0x49, 0xa0, 0xf4, 0xb0, 0xbf, 0x82, 0xeb, 0xde,
	0xf5, 0xa2, 0x1c, 0xe6, 0x76, 0x8c, 0x02, 0xd5, 0x79, 0x79, 0xf7, 0x45, 0x01, 0xa5, 0x80, 0xd3,
	0x85, 0x23, 0xef, 0xfd, 0x55, 0x28, 0x4a, 0x8c, 0xfe, 0xa3, 0x3f, 0xae, 0x9a, 0xc6, 0x9f, 0x57,
	0x4d, 0xe3, 0xef, 0xab, 0xa6, 0xf1, 0xcb, 0xbf, 0xcd, 0x15, 0xd8, 0x0c, 0xa2, 0x25, 0x88, 0x7d,
	0x70, 0xe4, 0xdf, 0x53, 0x29, 0x79, 0x6a, 0x8c, 0x56, 0x95, 0xea, 0xa3, 0xff, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x67, 0x22, 0xe3, 0xa4, 0x7d, 0x09, 0x00, 0x00,
}
